outfiles <- WritePhenoGenoToFile(GWASPolyRunVersion,trait,phenoSubsetGeno,SCMVPanel_nwithpos,Seq,DataSet)
#now we run the GWASpoly with the files in the proper format
data <- read.GWASpoly(ploidy=2,
pheno.file = outfiles[1],
geno.file=outfiles[2],
format="numeric",
n.traits=7,
delim=",")
data2 <- set.K(data, LOCO=TRUE)
params <- set.params(fixed=fixedEffect, fixed.type=fixedType,n.PC = 3, MAF = 0.025) #no fixed effects, MAF should do nothing as it's already been filtered
data3 <- GWASpoly(data2,models=c("general", "additive"),traits=trait, params=params)
visfileprefix <- paste0("Figures/GWASpoly/WSMDP_Carb_GWASpoly_",Seq,"_",DataSet,"_",GWASPolyRunVersion,"_",trait,"_",Thresh)
QQplotfile <- paste(visfileprefix,"_QQplot_General.png", sep = "")
png(QQplotfile, width = 500, height = 500)
#,"1-dom-alt-alt","1-dom-alt-ref","1-dom-ref-alt","1-dom-ref-ref")
print(qq.plot(data3,trait=trait,model="general"))
dev.off()
data4 <- set.threshold(data3,method=Thresh,level=0.05)
data5 <- get.QTL(data4)
#Here's the QTLS found
print(get.QTL(data4))
knitr::kable(data5)
# Models <- data5$Model
# Markers <- data5$Marker[which(data5$Score >= data5$Threshold)] ## this one works!!!
# trait <- data5$Trait
data5$R2 <- ""
fit.ans <- fit.QTL(data=data4,trait=trait,
qtl=data5[,c("Marker","Model")],
fixed=data.frame(Effect="endo",Type="factor"))
knitr::kable(fit.ans,digits=3)
# Models <- data5$Model
# Markers <- data5$Marker[which(data5$Score >= data5$Threshold)] ## this one works!!!
# trait <- data5$Trait
data5$R2 <- ""
fit.ans <- fit.QTL(data=data4,trait=trait,
qtl=data5[,c("Marker","Model")],
fixed=data.frame(Effect="endo",Type="factor"))
data4
data5
data3
fit.ans <- fit.QTL(data=data4,trait=trait,
qtl=data5[,c("Marker","Model")],
fixed=data.frame(Effect="endo",Type="factor"))
trait
data5
fit.ans <- fit.QTL(data=data4,trait=trait,
qtl=data5[,c("Marker","Model")],
fixed=data.frame(Effect="endo",Type="factor"))
data5[,c("Marker","Model")]
fit.ans <- fit.QTL(data=data4,trait=trait,
qtl=data5[,c("Marker","Model")],
fixed=data.frame(Effect="endo",Type="factor"))
data.frame(Effect="endo",Type="factor"))
data.frame(Effect="endo",Type="factor")
knitr::kable(fit.ans,digits=3)
fit.QTL
qtl=data5[,c("Marker","Model")]
data=data4
fixed=data.frame(Effect="endo",Type="factor")
stopifnot(inherits(data, "GWASpoly.K"))
stopifnot(is.element(trait, names(data@scores)))
stopifnot(qtl$Model %in% c("additive", "general",
paste(1:(data@ploidy/2), "dom-ref", sep = "-"),
paste(1:(data@ploidy/2), "dom-alt", sep = "-")))
stopifnot(qtl$Marker %in% data@map$Marker)
not.miss <- which(!is.na(data@pheno[, trait]))
not.miss
y <- data@pheno[not.miss, trait]
pheno.gid <- data@pheno[not.miss, 1]
geno.gid <- rownames(data@geno)
pheno.gid
geno.gid
n.gid <- length(geno.gid)
n <- length(y)
Z <- matrix(0, n, n.gid)
Z[cbind(1:n, match(pheno.gid, geno.gid))] <- 1
X <- matrix(1, n, 1)
if (!is.null(fixed)) {
for (i in 1:nrow(fixed)) {
if (fixed$Type[i] == "factor") {
xx <- factor(data@fixed[not.miss, fixed$Effect[i]])
if (length(levels(xx)) > 1) {
X <- cbind(X, model.matrix(~x, data.frame(x = xx))[,
-1])
}
}
else {
X <- cbind(X, data@fixed[not.miss, fixed$Effect[i]])
}
}
}
chrom <- as.character(data@map$Chrom[match(qtl$Marker, data@map$Marker)])
if (length(data@K) > 1) {
K <- makeLOCO(data@K, exclude = match(chrom, levels(data@map$Chrom)))
}
length(data@K)
K <- GWASPoly::(data@K, exclude = match(chrom, levels(data@map$Chrom)))
K <- GWASPoly::makeLOCO(data@K, exclude = match(chrom, levels(data@map$Chrom)))
K <- GWASPoly-master::makeLOCO(data@K, exclude = match(chrom, levels(data@map$Chrom)))
K <- GWASpoly-master::::makeLOCO(data@K, exclude = match(chrom, levels(data@map$Chrom)))
GWASpoly-master::]
K <- GWASpoly-master::makeLOCO(data@K, exclude = match(chrom, levels(data@map$Chrom)))
GWASPoly::makeLOCO
makeLOCO <- function(K,exclude) {
#K is list
#exclude is vector of indices
n.chr <- length(K)
tmp <- K[[1]]*0
keep <- setdiff(1:n.chr,exclude)
for (i in keep) {
tmp <- tmp + K[[i]]
}
return(tmp/length(keep))
}
K <- makeLOCO(data@K, exclude = match(chrom, levels(data@map$Chrom)))
n.qtl <- nrow(qtl)
S <- vector("list", n.qtl)
df <- integer(n.qtl)
X0 <- X
for (i in 1:n.qtl) {
S[[i]] <- .design.score(data@geno[, qtl$Marker[i]], model = qtl$Model[i],
ploidy = data@ploidy, min.MAF = 0, max.geno.freq = 1)
stopifnot(!is.null(S[[i]]))
df[i] <- ncol(S[[i]])
X <- cbind(X, Z %*% S[[i]])
}
.design.score <- function(Mi,model,ploidy,min.MAF,max.geno.freq){
n <- length(Mi)
freq <- mean(Mi,na.rm=T)/ploidy
if (min(freq,1-freq) < min.MAF){
return(NULL)
} else {
if (model=="additive") {
geno.freq <- table(round(Mi))/n
if (max(geno.freq) <= max.geno.freq) {
return(matrix(Mi))
} else {
return(NULL)
}
} else {
Mi <- round(Mi)
if (model=="diplo-additive") {
Mi[which((Mi>0)&(Mi<ploidy))] <- ploidy/2
Mi <- Mi/(ploidy/2)
geno.freq <- table(Mi)/n
if (max(geno.freq) <= max.geno.freq) {
return(matrix(Mi))
} else {
return(NULL)
}
}
if (model=="diplo-general") {
Mi[(Mi>0)&(Mi<ploidy)] <- ploidy/2
Mi <- Mi/(ploidy/2)
geno.freq <- table(Mi)/n
if (max(geno.freq)<=max.geno.freq) {
tmp <- model.matrix(~x,data.frame(x=factor(Mi)))[,-1]
if (is.null(dim(tmp))) {
return(matrix(tmp))
} else {
return(tmp)
}
} else {
return(NULL)
}
}
if (length(grep("dom",model,fixed=T))>0) {
tmp <- strsplit(model,split="-",fixed=T)[[1]]
dom.order <- as.integer(tmp[1])
if (tmp[3]=="alt") {
Mi <- ifelse(Mi>=dom.order,1,0)
} else {
Mi <- ifelse(Mi<=ploidy-dom.order,0,1)
}
geno.freq <- table(Mi)/n
if (max(geno.freq) <= max.geno.freq) {
return(matrix(Mi))
} else {
return(NULL)
}
}
if (model=="general") {
geno.freq <- table(Mi)/n
if (max(geno.freq)<=max.geno.freq) {
tmp <- model.matrix(~x,data.frame(x=factor(Mi)))[,-1]
if (is.null(dim(tmp))) {
return(matrix(tmp))
} else {
return(tmp)
}
} else {
return(NULL)
}
}
}
}
}
for (i in 1:n.qtl) {
S[[i]] <- .design.score(data@geno[, qtl$Marker[i]], model = qtl$Model[i],
ploidy = data@ploidy, min.MAF = 0, max.geno.freq = 1)
stopifnot(!is.null(S[[i]]))
df[i] <- ncol(S[[i]])
X <- cbind(X, Z %*% S[[i]])
}
full.model <- mixed.solve(y = y, X = .make.full(X), Z = Z,
K = K, method = "ML")
fit.ans <- fit.QTL(data=data4,trait=trait,
qtl=data5[,c("Marker","Model")],
fixed=data.frame(Effect="endo",Type="factor"))
#Import the name of the file. This matrix was calculated on Tassel using the Linkage Disequilibrium tool and the output was saved as a text file
#since the resulting text file was 8GB, it was pruned using AWK on linux to only include the columns for distance and r2 and only those with results, non with NA as the r2
LDMatrixfileName <- "WSMDP_SeqG_NoLD_InbredsPruned_LDDecay_200Window_JustLociDistR2_NoNAs"
fullpath <- paste("Data/RawData",LDMatrixfileName,".txt",sep = "")
#Read in the .txt LD matric file
readin <- fread(fullpath, sep=' ')
fullpath <- paste("Data/RawData/",LDMatrixfileName,".txt",sep = "")
#Read in the .txt LD matrix file
readin <- fread(fullpath, sep=' ')
#Uncomment if all the chromosomes want to be visualized individually, or just the whole geno.
# chrmiterant <- c("All",6)
chrmiterant <- c("All")
length(chrmiterant)
j
chrmnum = chrmiterant[j]
data <- readin
#Look at only one chromosome at a time
if(chrmnum != "All"){
data <- data[data$Locus1 == chrmnum]}
#uncomment these if the Matrix file has more than two columns. Eliminate any columns not r2 or dist
# data <- data[,c(13,14)]
data <- data[,c(3,4)]
head(data)
#Read in the .txt LD matrix file
readin <- fread(fullpath, sep='\t')
readin
chrmnum = chrmiterant[j]
data <- readin
#Look at only one chromosome at a time
if(chrmnum != "All"){
data <- data[data$Locus1 == chrmnum]}
#uncomment these if the Matrix file has more than two columns. Eliminate any columns not r2 or dist
# data <- data[,c(13,14)]
data <- data[,c(3,4)]
data
data <- readin
#uncomment these if the Matrix file has more than two columns. Eliminate any columns not r2 or dist
# data <- data[,c(13,14)]
# data <- data[,c(3,4)]
data <- data[,c(5,6)]
data
data
head(data)
#seperate the distances between chromosomes into 20 bins
numbins = 20
#change this if wanting to not log transfrom the data
log_transform = TRUE
absolute_distance = TRUE
#change this if you want to eliminate any comparisons less than 500bp apart
removefirst500 = FALSE
names(data)=c("dist","rsq")
data$dist <-as.numeric(data$dist)
medians=get.median(data, log_transform=log_transform, numbins = numbins, removefirst500 = removefirst500)
#establish the working directory
setwd("C:/Users/LHislop/Documents/GitHub/WSMDP_SCMV/")
source("getmedianLDVis.R")
source("getpercentileLDVis.R")
setwd("C:/Users/LHislop/Documents/GitHub/WSMDP_Carb")
medians=get.median(data, log_transform=log_transform, numbins = numbins, removefirst500 = removefirst500)
medians
write.table(medians, file="medians.txt",quote=FALSE,sep="\t", col.names=TRUE, row.names=T)
probs=c(0.5, 0.6, 0.7, 0.8, 0.9)
percents=get.percentiles(data, probs=probs, log_transform=log_transform, numbins = numbins, removefirst500 = removefirst500)
write.table(percents, file="percents.txt",quote=FALSE,sep="\t", col.names=TRUE, row.names=T)
mean=tapply(X=data$rsq, INDEX=cut(data$dist, breaks=numbins), FUN=mean, na.rm=T)
percents=read.table('percents.txt',sep='\t',header=T,row.names=1)
medians=read.table('medians.txt',sep='\t',header=T,row.names=1)
probs=c('50%','60%','70%','80%','90%')
colnames(percents) <- probs
## Add all together
row.names(percents)[20]
#the rownames are the starting and end distance of each bin. convert that into a more usable format
xvals = as.numeric(sub(rownames(percents), pattern="\\((.+),.+", repl="\\1"))
xvals = c(xvals,8.49)
mean.xvals <- NULL
#find the middle between each bin border. This will be used for the Xlabel
for (i in 1:c(length(xvals)-1)){
mean.xvals <- c(mean.xvals,mean(c(xvals[i],xvals[i+1])))
}
#determine the file name to save the visualization
if(removefirst500 == TRUE){
outfile = paste("Figures/LD_20bins_less500bprmv_from",LDMatrixfileName,"_Chrm",chrmnum,".pdf",sep = "")}
if(removefirst500 == FALSE){
outfile = paste("Figures/LD_20bins_from",LDMatrixfileName,"_Chrm",chrmnum,".pdf",sep = "")
}
#plot and save the visualization
{pdf(outfile, pointsize=8,family='serif',width = 5,height = 3.5)
lwd=1
ylim=c(0,1)
xlim= c(0, range(mean.xvals)[2] * 1.1)	# Increase the upper xlim by a little bit
par(cex=1,mar=c(5,5,1,1))
if(log_transform == TRUE){
xlabel = "Physical distance (log scale)"
}else{
xlabel = "Distance"
}
plot(NA, xlim=xlim, ylim=ylim, xlab=xlabel, ylab=bquote("Linkage disequilibrium"~(italic(r)^2)), xaxt="n")	#CHD added
if(log_transform == TRUE){
x_ticks = 0:8
x_labels=c("1 bp","10 bp","0.1 kb","1 kb","10 kb","100 kb","1 Mb","10 Mb","100 Mb") #Jason original
} else{
x_ticks = seq(from=xlim[1], to=xlim[2], length.out=5)
x_labels = x_ticks
}
axis(side=1, at=x_ticks, labels=x_labels)
for(j in 1:length(probs)){
lines(x=mean.xvals, y=percents[,j], lwd=lwd, col='black', lty=j)
}
text(x=sort(xvals)[8], y=c(0.11,0.30,0.46,0.68,0.9), labels=colnames(percents), pos=4, cex = 1)
dev.off()
}
mean.xvals
#plot and save the visualization
# {pdf(outfile, pointsize=8,family='serif',width = 5,height = 3.5)
{png(outfile, pointsize=8,family='serif',width = 500,height = 500)
lwd=1
ylim=c(0,1)
xlim= c(0, range(mean.xvals)[2] * 1.1)	# Increase the upper xlim by a little bit
par(cex=1,mar=c(5,5,1,1))
if(log_transform == TRUE){
xlabel = "Physical distance (log scale)"
}else{
xlabel = "Distance"
}
plot(NA, xlim=xlim, ylim=ylim, xlab=xlabel, ylab=bquote("Linkage disequilibrium"~(italic(r)^2)), xaxt="n")	#CHD added
if(log_transform == TRUE){
x_ticks = 0:8
x_labels=c("1 bp","10 bp","0.1 kb","1 kb","10 kb","100 kb","1 Mb","10 Mb","100 Mb") #Jason original
} else{
x_ticks = seq(from=xlim[1], to=xlim[2], length.out=5)
x_labels = x_ticks
}
axis(side=1, at=x_ticks, labels=x_labels)
for(j in 1:length(probs)){
lines(x=mean.xvals, y=percents[,j], lwd=lwd, col='black', lty=j)
}
text(x=sort(xvals)[8], y=c(0.11,0.30,0.46,0.68,0.9), labels=colnames(percents), pos=4, cex = 1)
dev.off()
}
#plot and save the visualization
# {pdf(outfile, pointsize=8,family='serif',width = 5,height = 3.5)
{png(outfile, pointsize=8,family='serif',width = 500,height = 500)
lwd=1
ylim=c(0,1)
xlim= c(0, range(mean.xvals)[2] * 1.1)	# Increase the upper xlim by a little bit
par(cex=1,mar=c(5,5,1,1))
if(log_transform == TRUE){
xlabel = "Physical distance (log scale)"
}else{
xlabel = "Distance"
}
plot(NA, xlim=xlim, ylim=ylim, xlab=xlabel, ylab=bquote("Linkage disequilibrium"~(italic(r)^2)), xaxt="n")	#CHD added
if(log_transform == TRUE){
x_ticks = 0:8
x_labels=c("1 bp","10 bp","0.1 kb","1 kb","10 kb","100 kb","1 Mb","10 Mb","100 Mb") #Jason original
} else{
x_ticks = seq(from=xlim[1], to=xlim[2], length.out=5)
x_labels = x_ticks
}
axis(side=1, at=x_ticks, labels=x_labels)
for(j in 1:length(probs)){
lines(x=mean.xvals, y=percents[,j], lwd=lwd, col='black', lty=j)
}
text(x=sort(xvals)[8], y=c(0.11,0.30,0.46,0.68,0.9), labels=colnames(percents), pos=4, cex = 1)
dev.off()
}
outfile = paste("Figures/LD_20bins_from",LDMatrixfileName,"_Chrm",chrmnum,".png",sep = "")
#plot and save the visualization
# {pdf(outfile, pointsize=8,family='serif',width = 5,height = 3.5)
{png(outfile, pointsize=8,family='serif',width = 500,height = 500)
lwd=1
ylim=c(0,1)
xlim= c(0, range(mean.xvals)[2] * 1.1)	# Increase the upper xlim by a little bit
par(cex=1,mar=c(5,5,1,1))
if(log_transform == TRUE){
xlabel = "Physical distance (log scale)"
}else{
xlabel = "Distance"
}
plot(NA, xlim=xlim, ylim=ylim, xlab=xlabel, ylab=bquote("Linkage disequilibrium"~(italic(r)^2)), xaxt="n")	#CHD added
if(log_transform == TRUE){
x_ticks = 0:8
x_labels=c("1 bp","10 bp","0.1 kb","1 kb","10 kb","100 kb","1 Mb","10 Mb","100 Mb") #Jason original
} else{
x_ticks = seq(from=xlim[1], to=xlim[2], length.out=5)
x_labels = x_ticks
}
axis(side=1, at=x_ticks, labels=x_labels)
for(j in 1:length(probs)){
lines(x=mean.xvals, y=percents[,j], lwd=lwd, col='black', lty=j)
}
text(x=sort(xvals)[8], y=c(0.11,0.30,0.46,0.68,0.9), labels=colnames(percents), pos=4, cex = 1)
dev.off()
}
#plot and save the visualization
# {pdf(outfile, pointsize=8,family='serif',width = 5,height = 3.5)
{png(outfile, pointsize=8,family='serif',width = 750,height = 500)
lwd=1
ylim=c(0,1)
xlim= c(0, range(mean.xvals)[2] * 1.1)	# Increase the upper xlim by a little bit
par(cex=1,mar=c(5,5,1,1))
if(log_transform == TRUE){
xlabel = "Physical distance (log scale)"
}else{
xlabel = "Distance"
}
plot(NA, xlim=xlim, ylim=ylim, xlab=xlabel, ylab=bquote("Linkage disequilibrium"~(italic(r)^2)), xaxt="n")	#CHD added
if(log_transform == TRUE){
x_ticks = 0:8
x_labels=c("1 bp","10 bp","0.1 kb","1 kb","10 kb","100 kb","1 Mb","10 Mb","100 Mb") #Jason original
} else{
x_ticks = seq(from=xlim[1], to=xlim[2], length.out=5)
x_labels = x_ticks
}
axis(side=1, at=x_ticks, labels=x_labels)
for(j in 1:length(probs)){
lines(x=mean.xvals, y=percents[,j], lwd=lwd, col='black', lty=j)
}
text(x=sort(xvals)[8], y=c(0.11,0.30,0.46,0.68,0.9), labels=colnames(percents), pos=4, cex = 1)
dev.off()
}
#plot and save the visualization
# {pdf(outfile, pointsize=8,family='serif',width = 5,height = 3.5)
{png(outfile, pointsize=8,family='serif',width = 500,height = 300)
lwd=1
ylim=c(0,1)
xlim= c(0, range(mean.xvals)[2] * 1.1)	# Increase the upper xlim by a little bit
par(cex=1,mar=c(5,5,1,1))
if(log_transform == TRUE){
xlabel = "Physical distance (log scale)"
}else{
xlabel = "Distance"
}
plot(NA, xlim=xlim, ylim=ylim, xlab=xlabel, ylab=bquote("Linkage disequilibrium"~(italic(r)^2)), xaxt="n")	#CHD added
if(log_transform == TRUE){
x_ticks = 0:8
x_labels=c("1 bp","10 bp","0.1 kb","1 kb","10 kb","100 kb","1 Mb","10 Mb","100 Mb") #Jason original
} else{
x_ticks = seq(from=xlim[1], to=xlim[2], length.out=5)
x_labels = x_ticks
}
axis(side=1, at=x_ticks, labels=x_labels)
for(j in 1:length(probs)){
lines(x=mean.xvals, y=percents[,j], lwd=lwd, col='black', lty=j)
}
text(x=sort(xvals)[8], y=c(0.11,0.30,0.46,0.68,0.9), labels=colnames(percents), pos=4, cex = 1)
dev.off()
}
outfile = paste("Figures/LD_20bins_from",LDMatrixfileName,"_Chrm",chrmnum,".pdf",sep = "")
#plot and save the visualization
# {pdf(outfile, pointsize=8,family='serif',width = 5,height = 3.5)
{png(outfile, pointsize=8,family='serif',width = 500,height = 300)
lwd=1
ylim=c(0,1)
xlim= c(0, range(mean.xvals)[2] * 1.1)	# Increase the upper xlim by a little bit
par(cex=1,mar=c(5,5,1,1))
if(log_transform == TRUE){
xlabel = "Physical distance (log scale)"
}else{
xlabel = "Distance"
}
plot(NA, xlim=xlim, ylim=ylim, xlab=xlabel, ylab=bquote("Linkage disequilibrium"~(italic(r)^2)), xaxt="n")	#CHD added
if(log_transform == TRUE){
x_ticks = 0:8
x_labels=c("1 bp","10 bp","0.1 kb","1 kb","10 kb","100 kb","1 Mb","10 Mb","100 Mb") #Jason original
} else{
x_ticks = seq(from=xlim[1], to=xlim[2], length.out=5)
x_labels = x_ticks
}
axis(side=1, at=x_ticks, labels=x_labels)
for(j in 1:length(probs)){
lines(x=mean.xvals, y=percents[,j], lwd=lwd, col='black', lty=j)
}
text(x=sort(xvals)[8], y=c(0.11,0.30,0.46,0.68,0.9), labels=colnames(percents), pos=4, cex = 1)
dev.off()
}
#plot and save the visualization
{pdf(outfile, pointsize=8,family='serif',width = 5,height = 3.5)
# {png(outfile, pointsize=8,family='serif',width = 500,height = 300)
lwd=1
ylim=c(0,1)
xlim= c(0, range(mean.xvals)[2] * 1.1)	# Increase the upper xlim by a little bit
par(cex=1,mar=c(5,5,1,1))
if(log_transform == TRUE){
xlabel = "Physical distance (log scale)"
}else{
xlabel = "Distance"
}
plot(NA, xlim=xlim, ylim=ylim, xlab=xlabel, ylab=bquote("Linkage disequilibrium"~(italic(r)^2)), xaxt="n")	#CHD added
if(log_transform == TRUE){
x_ticks = 0:8
x_labels=c("1 bp","10 bp","0.1 kb","1 kb","10 kb","100 kb","1 Mb","10 Mb","100 Mb") #Jason original
} else{
x_ticks = seq(from=xlim[1], to=xlim[2], length.out=5)
x_labels = x_ticks
}
axis(side=1, at=x_ticks, labels=x_labels)
for(j in 1:length(probs)){
lines(x=mean.xvals, y=percents[,j], lwd=lwd, col='black', lty=j)
}
text(x=sort(xvals)[8], y=c(0.11,0.30,0.46,0.68,0.9), labels=colnames(percents), pos=4, cex = 1)
dev.off()
}
